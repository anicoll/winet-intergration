package models

// Code generated by dbtpl. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Inverter represents a row from 'public.inverter'.
type Inverter struct {
	ID            string       `json:"id"`             // id
	State         string       `json:"state"`          // state
	BatteryState  string       `json:"battery_state"`  // battery_state
	ChargeRate    float64      `json:"charge_rate"`    // charge_rate
	FeedinEnabled bool         `json:"feedin_enabled"` // feedin_enabled
	CreatedAt     sql.NullTime `json:"created_at"`     // created_at
	UpdatedAt     sql.NullTime `json:"updated_at"`     // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Inverter] exists in the database.
func (i *Inverter) Exists() bool {
	return i._exists
}

// Deleted returns true when the [Inverter] has been marked for deletion
// from the database.
func (i *Inverter) Deleted() bool {
	return i._deleted
}

// Insert inserts the [Inverter] to the database.
func (i *Inverter) Insert(ctx context.Context, db DB) error {
	switch {
	case i._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case i._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.inverter (` +
		`id, state, battery_state, charge_rate, feedin_enabled, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)`
	// run
	logf(sqlstr, i.ID, i.State, i.BatteryState, i.ChargeRate, i.FeedinEnabled, i.CreatedAt, i.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, i.ID, i.State, i.BatteryState, i.ChargeRate, i.FeedinEnabled, i.CreatedAt, i.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	i._exists = true
	return nil
}

// Update updates a [Inverter] in the database.
func (i *Inverter) Update(ctx context.Context, db DB) error {
	switch {
	case !i._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case i._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.inverter SET ` +
		`state = $1, battery_state = $2, charge_rate = $3, feedin_enabled = $4, created_at = $5, updated_at = $6 ` +
		`WHERE id = $7`
	// run
	logf(sqlstr, i.State, i.BatteryState, i.ChargeRate, i.FeedinEnabled, i.CreatedAt, i.UpdatedAt, i.ID)
	if _, err := db.ExecContext(ctx, sqlstr, i.State, i.BatteryState, i.ChargeRate, i.FeedinEnabled, i.CreatedAt, i.UpdatedAt, i.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Inverter] to the database.
func (i *Inverter) Save(ctx context.Context, db DB) error {
	if i.Exists() {
		return i.Update(ctx, db)
	}
	return i.Insert(ctx, db)
}

// Upsert performs an upsert for [Inverter].
func (i *Inverter) Upsert(ctx context.Context, db DB) error {
	switch {
	case i._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.inverter (` +
		`id, state, battery_state, charge_rate, feedin_enabled, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`state = EXCLUDED.state, battery_state = EXCLUDED.battery_state, charge_rate = EXCLUDED.charge_rate, feedin_enabled = EXCLUDED.feedin_enabled, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, i.ID, i.State, i.BatteryState, i.ChargeRate, i.FeedinEnabled, i.CreatedAt, i.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, i.ID, i.State, i.BatteryState, i.ChargeRate, i.FeedinEnabled, i.CreatedAt, i.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	i._exists = true
	return nil
}

// Delete deletes the [Inverter] from the database.
func (i *Inverter) Delete(ctx context.Context, db DB) error {
	switch {
	case !i._exists: // doesn't exist
		return nil
	case i._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.inverter ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, i.ID)
	if _, err := db.ExecContext(ctx, sqlstr, i.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	i._deleted = true
	return nil
}

// InverterByID retrieves a row from 'public.inverter' as a [Inverter].
//
// Generated from index 'inverter_pkey'.
func InverterByID(ctx context.Context, db DB, id string) (*Inverter, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, state, battery_state, charge_rate, feedin_enabled, created_at, updated_at ` +
		`FROM public.inverter ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	i := Inverter{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&i.ID, &i.State, &i.BatteryState, &i.ChargeRate, &i.FeedinEnabled, &i.CreatedAt, &i.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &i, nil
}

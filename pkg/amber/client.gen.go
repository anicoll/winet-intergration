// Package amber provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package amber

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyScopes = "apiKey.Scopes"
)

// Defines values for ActualIntervalDuration.
const (
	ActualIntervalDurationN15 ActualIntervalDuration = 15
	ActualIntervalDurationN30 ActualIntervalDuration = 30
	ActualIntervalDurationN5  ActualIntervalDuration = 5
)

// Defines values for ActualIntervalType.
const (
	ActualIntervalTypeActualInterval ActualIntervalType = "ActualInterval"
)

// Defines values for ActualRenewableDuration.
const (
	ActualRenewableDurationN15 ActualRenewableDuration = 15
	ActualRenewableDurationN30 ActualRenewableDuration = 30
	ActualRenewableDurationN5  ActualRenewableDuration = 5
)

// Defines values for BaseIntervalDuration.
const (
	BaseIntervalDurationN15 BaseIntervalDuration = 15
	BaseIntervalDurationN30 BaseIntervalDuration = 30
	BaseIntervalDurationN5  BaseIntervalDuration = 5
)

// Defines values for BaseRenewableDuration.
const (
	BaseRenewableDurationN15 BaseRenewableDuration = 15
	BaseRenewableDurationN30 BaseRenewableDuration = 30
	BaseRenewableDurationN5  BaseRenewableDuration = 5
)

// Defines values for ChannelType.
const (
	ControlledLoad ChannelType = "controlledLoad"
	FeedIn         ChannelType = "feedIn"
	General        ChannelType = "general"
)

// Defines values for CurrentIntervalDuration.
const (
	CurrentIntervalDurationN15 CurrentIntervalDuration = 15
	CurrentIntervalDurationN30 CurrentIntervalDuration = 30
	CurrentIntervalDurationN5  CurrentIntervalDuration = 5
)

// Defines values for CurrentIntervalType.
const (
	CurrentIntervalTypeCurrentInterval CurrentIntervalType = "CurrentInterval"
)

// Defines values for CurrentRenewableDuration.
const (
	CurrentRenewableDurationN15 CurrentRenewableDuration = 15
	CurrentRenewableDurationN30 CurrentRenewableDuration = 30
	CurrentRenewableDurationN5  CurrentRenewableDuration = 5
)

// Defines values for ForecastIntervalDuration.
const (
	ForecastIntervalDurationN15 ForecastIntervalDuration = 15
	ForecastIntervalDurationN30 ForecastIntervalDuration = 30
	ForecastIntervalDurationN5  ForecastIntervalDuration = 5
)

// Defines values for ForecastIntervalType.
const (
	ForecastIntervalTypeForecastInterval ForecastIntervalType = "ForecastInterval"
)

// Defines values for ForecastRenewableDuration.
const (
	ForecastRenewableDurationN15 ForecastRenewableDuration = 15
	ForecastRenewableDurationN30 ForecastRenewableDuration = 30
	ForecastRenewableDurationN5  ForecastRenewableDuration = 5
)

// Defines values for PriceDescriptor.
const (
	PriceDescriptorExtremelyLow PriceDescriptor = "extremelyLow"
	PriceDescriptorHigh         PriceDescriptor = "high"
	PriceDescriptorLow          PriceDescriptor = "low"
	PriceDescriptorNegative     PriceDescriptor = "negative"
	PriceDescriptorNeutral      PriceDescriptor = "neutral"
	PriceDescriptorSpike        PriceDescriptor = "spike"
	PriceDescriptorVeryLow      PriceDescriptor = "veryLow"
)

// Defines values for RenewableDescriptor.
const (
	Best     RenewableDescriptor = "best"
	Great    RenewableDescriptor = "great"
	NotGreat RenewableDescriptor = "notGreat"
	Ok       RenewableDescriptor = "ok"
	Worst    RenewableDescriptor = "worst"
)

// Defines values for SiteIntervalLength.
const (
	SiteIntervalLengthN30 SiteIntervalLength = 30
	SiteIntervalLengthN5  SiteIntervalLength = 5
)

// Defines values for SiteStatus.
const (
	Active  SiteStatus = "active"
	Closed  SiteStatus = "closed"
	Pending SiteStatus = "pending"
)

// Defines values for SpikeStatus.
const (
	SpikeStatusNone      SpikeStatus = "none"
	SpikeStatusPotential SpikeStatus = "potential"
	SpikeStatusSpike     SpikeStatus = "spike"
)

// Defines values for TariffInformationPeriod.
const (
	OffPeak     TariffInformationPeriod = "offPeak"
	Peak        TariffInformationPeriod = "peak"
	Shoulder    TariffInformationPeriod = "shoulder"
	SolarSponge TariffInformationPeriod = "solarSponge"
)

// Defines values for TariffInformationSeason.
const (
	Autumn         TariffInformationSeason = "autumn"
	Default        TariffInformationSeason = "default"
	Holiday        TariffInformationSeason = "holiday"
	NonSummer      TariffInformationSeason = "nonSummer"
	Spring         TariffInformationSeason = "spring"
	Summer         TariffInformationSeason = "summer"
	Weekday        TariffInformationSeason = "weekday"
	Weekend        TariffInformationSeason = "weekend"
	WeekendHoliday TariffInformationSeason = "weekendHoliday"
	Winter         TariffInformationSeason = "winter"
)

// Defines values for UsageDuration.
const (
	UsageDurationN15 UsageDuration = 15
	UsageDurationN30 UsageDuration = 30
	UsageDurationN5  UsageDuration = 5
)

// Defines values for UsageQuality.
const (
	Billable  UsageQuality = "billable"
	Estimated UsageQuality = "estimated"
)

// Defines values for UsageType.
const (
	UsageTypeUsage UsageType = "Usage"
)

// Defines values for GetPricesParamsResolution.
const (
	GetPricesParamsResolutionN30 GetPricesParamsResolution = 30
	GetPricesParamsResolutionN5  GetPricesParamsResolution = 5
)

// Defines values for GetCurrentPricesParamsResolution.
const (
	GetCurrentPricesParamsResolutionN30 GetCurrentPricesParamsResolution = 30
	GetCurrentPricesParamsResolutionN5  GetCurrentPricesParamsResolution = 5
)

// Defines values for GetUsageParamsResolution.
const (
	GetUsageParamsResolutionN30 GetUsageParamsResolution = 30
)

// Defines values for GetCurrentRenewablesParamsResolution.
const (
	GetCurrentRenewablesParamsResolutionN30 GetCurrentRenewablesParamsResolution = 30
	GetCurrentRenewablesParamsResolutionN5  GetCurrentRenewablesParamsResolution = 5
)

// ActualInterval defines model for ActualInterval.
type ActualInterval struct {
	// ChannelType Meter channel type
	ChannelType ChannelType `json:"channelType"`

	// Date Date the interval belongs to (in NEM time). This may be different to the date component of nemTime, as the last interval of the day ends at 12:00 the following day. Formatted as a ISO 8601 date
	Date openapi_types.Date `json:"date"`

	// Descriptor Describes the current price. Gives you an indication of how cheap the price is in relation to the average VMO and DMO. Note: Negative is no longer used. It has been replaced with extremelyLow.
	Descriptor PriceDescriptor `json:"descriptor"`

	// Duration Length of the interval in minutes.
	Duration ActualIntervalDuration `json:"duration"`

	// EndTime End time of the interval in UTC. Formatted as a ISO 8601 time
	EndTime time.Time `json:"endTime"`

	// NemTime The interval's NEM time. This represents the time at the end of the interval UTC+10. Formatted as a ISO 8601 time
	NemTime time.Time `json:"nemTime"`

	// PerKwh Number of cents you will pay per kilowatt-hour (c/kWh) - includes GST
	PerKwh float32 `json:"perKwh"`

	// Renewables Percentage of renewables in the grid
	Renewables float32 `json:"renewables"`

	// SpikeStatus Indicates whether this interval will potentially spike, or is currently in a spike state
	SpikeStatus SpikeStatus `json:"spikeStatus"`

	// SpotPerKwh NEM spot price (c/kWh). This is the price generators get paid to generate electricity, and what drives the variable component of your perKwh price - includes GST
	SpotPerKwh float32 `json:"spotPerKwh"`

	// StartTime Start time of the interval in UTC. Formatted as a ISO 8601 time
	StartTime         time.Time          `json:"startTime"`
	TariffInformation *TariffInformation `json:"tariffInformation"`
	Type              ActualIntervalType `json:"type"`
}

// ActualIntervalDuration Length of the interval in minutes.
type ActualIntervalDuration int

// ActualIntervalType defines model for ActualInterval.Type.
type ActualIntervalType string

// ActualRenewable defines model for ActualRenewable.
type ActualRenewable struct {
	// Date Date the interval belongs to (in NEM time). This may be different to the date component of nemTime, as the last interval of the day ends at 12:00 the following day. Formatted as a ISO 8601 date
	Date openapi_types.Date `json:"date"`

	// Descriptor Describes the state of renewables. Gives you an indication of how green power is right now
	Descriptor RenewableDescriptor `json:"descriptor"`

	// Duration Length of the interval in minutes.
	Duration ActualRenewableDuration `json:"duration"`

	// EndTime End time of the interval in UTC. Formatted as a ISO 8601 time
	EndTime time.Time `json:"endTime"`

	// NemTime The interval's NEM time. This represents the time at the end of the interval UTC+10. Formatted as a ISO 8601 time
	NemTime time.Time `json:"nemTime"`

	// Renewables Percentage of renewables in the grid
	Renewables float32 `json:"renewables"`

	// StartTime Start time of the interval in UTC. Formatted as a ISO 8601 time
	StartTime time.Time `json:"startTime"`
	Type      string    `json:"type"`
}

// ActualRenewableDuration Length of the interval in minutes.
type ActualRenewableDuration int

// AdvancedPrice Amber has created an advanced forecast system, that represents our confidence in the AEMO forecast. The range indicates where we think the price will land for a given interval.
type AdvancedPrice struct {
	// High The upper bound of our prediction band. Price includes network and market fees. (c/kWh).
	High float32 `json:"high"`

	// Low The lower bound of our prediction band. Price includes network and market fees. (c/kWh).
	Low float32 `json:"low"`

	// Predicted The predicted price. Use this if you need a single number to forecast against. Price includes network and market fees. (c/kWh).
	Predicted float32 `json:"predicted"`
}

// BaseInterval One time interval
type BaseInterval struct {
	// ChannelType Meter channel type
	ChannelType ChannelType `json:"channelType"`

	// Date Date the interval belongs to (in NEM time). This may be different to the date component of nemTime, as the last interval of the day ends at 12:00 the following day. Formatted as a ISO 8601 date
	Date openapi_types.Date `json:"date"`

	// Descriptor Describes the current price. Gives you an indication of how cheap the price is in relation to the average VMO and DMO. Note: Negative is no longer used. It has been replaced with extremelyLow.
	Descriptor PriceDescriptor `json:"descriptor"`

	// Duration Length of the interval in minutes.
	Duration BaseIntervalDuration `json:"duration"`

	// EndTime End time of the interval in UTC. Formatted as a ISO 8601 time
	EndTime time.Time `json:"endTime"`

	// NemTime The interval's NEM time. This represents the time at the end of the interval UTC+10. Formatted as a ISO 8601 time
	NemTime time.Time `json:"nemTime"`

	// PerKwh Number of cents you will pay per kilowatt-hour (c/kWh) - includes GST
	PerKwh float32 `json:"perKwh"`

	// Renewables Percentage of renewables in the grid
	Renewables float32 `json:"renewables"`

	// SpikeStatus Indicates whether this interval will potentially spike, or is currently in a spike state
	SpikeStatus SpikeStatus `json:"spikeStatus"`

	// SpotPerKwh NEM spot price (c/kWh). This is the price generators get paid to generate electricity, and what drives the variable component of your perKwh price - includes GST
	SpotPerKwh float32 `json:"spotPerKwh"`

	// StartTime Start time of the interval in UTC. Formatted as a ISO 8601 time
	StartTime         time.Time          `json:"startTime"`
	TariffInformation *TariffInformation `json:"tariffInformation"`
	Type              string             `json:"type"`
}

// BaseIntervalDuration Length of the interval in minutes.
type BaseIntervalDuration int

// BaseRenewable Renewable data
type BaseRenewable struct {
	// Date Date the interval belongs to (in NEM time). This may be different to the date component of nemTime, as the last interval of the day ends at 12:00 the following day. Formatted as a ISO 8601 date
	Date openapi_types.Date `json:"date"`

	// Descriptor Describes the state of renewables. Gives you an indication of how green power is right now
	Descriptor RenewableDescriptor `json:"descriptor"`

	// Duration Length of the interval in minutes.
	Duration BaseRenewableDuration `json:"duration"`

	// EndTime End time of the interval in UTC. Formatted as a ISO 8601 time
	EndTime time.Time `json:"endTime"`

	// NemTime The interval's NEM time. This represents the time at the end of the interval UTC+10. Formatted as a ISO 8601 time
	NemTime time.Time `json:"nemTime"`

	// Renewables Percentage of renewables in the grid
	Renewables float32 `json:"renewables"`

	// StartTime Start time of the interval in UTC. Formatted as a ISO 8601 time
	StartTime time.Time `json:"startTime"`
	Type      string    `json:"type"`
}

// BaseRenewableDuration Length of the interval in minutes.
type BaseRenewableDuration int

// Channel Describes a power meter channel.
//
// The General channel provides continuous power - it's the channel all of your appliances and lights are attached to.
//
// Controlled loads are only on for a limited time during the day (usually when the load on the network is low, or generation is high) - you may have your hot water system attached to this channel.
//
// The feed in channel sends power back to the grid - you will have these types of channels if you have solar or batteries.
type Channel struct {
	// Identifier Identifier of the channel
	Identifier string `json:"identifier"`

	// Tariff The tariff code of the channel
	Tariff string `json:"tariff"`

	// Type Meter channel type
	Type ChannelType `json:"type"`
}

// ChannelType Meter channel type
type ChannelType string

// CurrentInterval defines model for CurrentInterval.
type CurrentInterval struct {
	// AdvancedPrice Amber has created an advanced forecast system, that represents our confidence in the AEMO forecast. The range indicates where we think the price will land for a given interval.
	AdvancedPrice *AdvancedPrice `json:"advancedPrice,omitempty"`

	// ChannelType Meter channel type
	ChannelType ChannelType `json:"channelType"`

	// Date Date the interval belongs to (in NEM time). This may be different to the date component of nemTime, as the last interval of the day ends at 12:00 the following day. Formatted as a ISO 8601 date
	Date openapi_types.Date `json:"date"`

	// Descriptor Describes the current price. Gives you an indication of how cheap the price is in relation to the average VMO and DMO. Note: Negative is no longer used. It has been replaced with extremelyLow.
	Descriptor PriceDescriptor `json:"descriptor"`

	// Duration Length of the interval in minutes.
	Duration CurrentIntervalDuration `json:"duration"`

	// EndTime End time of the interval in UTC. Formatted as a ISO 8601 time
	EndTime time.Time `json:"endTime"`

	// Estimate Shows true the current price is an estimate. Shows false is the price has been locked in.
	Estimate bool `json:"estimate"`

	// NemTime The interval's NEM time. This represents the time at the end of the interval UTC+10. Formatted as a ISO 8601 time
	NemTime time.Time `json:"nemTime"`

	// PerKwh Number of cents you will pay per kilowatt-hour (c/kWh) - includes GST
	PerKwh float32 `json:"perKwh"`

	// Range When prices are particularly volatile, the API may return a range of NEM spot prices (c/kWh) that are possible.
	Range *Range `json:"range,omitempty"`

	// Renewables Percentage of renewables in the grid
	Renewables float32 `json:"renewables"`

	// SpikeStatus Indicates whether this interval will potentially spike, or is currently in a spike state
	SpikeStatus SpikeStatus `json:"spikeStatus"`

	// SpotPerKwh NEM spot price (c/kWh). This is the price generators get paid to generate electricity, and what drives the variable component of your perKwh price - includes GST
	SpotPerKwh float32 `json:"spotPerKwh"`

	// StartTime Start time of the interval in UTC. Formatted as a ISO 8601 time
	StartTime         time.Time           `json:"startTime"`
	TariffInformation *TariffInformation  `json:"tariffInformation"`
	Type              CurrentIntervalType `json:"type"`
}

// CurrentIntervalDuration Length of the interval in minutes.
type CurrentIntervalDuration int

// CurrentIntervalType defines model for CurrentInterval.Type.
type CurrentIntervalType string

// CurrentRenewable defines model for CurrentRenewable.
type CurrentRenewable struct {
	// Date Date the interval belongs to (in NEM time). This may be different to the date component of nemTime, as the last interval of the day ends at 12:00 the following day. Formatted as a ISO 8601 date
	Date openapi_types.Date `json:"date"`

	// Descriptor Describes the state of renewables. Gives you an indication of how green power is right now
	Descriptor RenewableDescriptor `json:"descriptor"`

	// Duration Length of the interval in minutes.
	Duration CurrentRenewableDuration `json:"duration"`

	// EndTime End time of the interval in UTC. Formatted as a ISO 8601 time
	EndTime time.Time `json:"endTime"`

	// NemTime The interval's NEM time. This represents the time at the end of the interval UTC+10. Formatted as a ISO 8601 time
	NemTime time.Time `json:"nemTime"`

	// Renewables Percentage of renewables in the grid
	Renewables float32 `json:"renewables"`

	// StartTime Start time of the interval in UTC. Formatted as a ISO 8601 time
	StartTime time.Time `json:"startTime"`
	Type      string    `json:"type"`
}

// CurrentRenewableDuration Length of the interval in minutes.
type CurrentRenewableDuration int

// ForecastInterval defines model for ForecastInterval.
type ForecastInterval struct {
	// AdvancedPrice Amber has created an advanced forecast system, that represents our confidence in the AEMO forecast. The range indicates where we think the price will land for a given interval.
	AdvancedPrice *AdvancedPrice `json:"advancedPrice,omitempty"`

	// ChannelType Meter channel type
	ChannelType ChannelType `json:"channelType"`

	// Date Date the interval belongs to (in NEM time). This may be different to the date component of nemTime, as the last interval of the day ends at 12:00 the following day. Formatted as a ISO 8601 date
	Date openapi_types.Date `json:"date"`

	// Descriptor Describes the current price. Gives you an indication of how cheap the price is in relation to the average VMO and DMO. Note: Negative is no longer used. It has been replaced with extremelyLow.
	Descriptor PriceDescriptor `json:"descriptor"`

	// Duration Length of the interval in minutes.
	Duration ForecastIntervalDuration `json:"duration"`

	// EndTime End time of the interval in UTC. Formatted as a ISO 8601 time
	EndTime time.Time `json:"endTime"`

	// NemTime The interval's NEM time. This represents the time at the end of the interval UTC+10. Formatted as a ISO 8601 time
	NemTime time.Time `json:"nemTime"`

	// PerKwh Number of cents you will pay per kilowatt-hour (c/kWh) - includes GST
	PerKwh float32 `json:"perKwh"`

	// Range When prices are particularly volatile, the API may return a range of NEM spot prices (c/kWh) that are possible.
	Range *Range `json:"range,omitempty"`

	// Renewables Percentage of renewables in the grid
	Renewables float32 `json:"renewables"`

	// SpikeStatus Indicates whether this interval will potentially spike, or is currently in a spike state
	SpikeStatus SpikeStatus `json:"spikeStatus"`

	// SpotPerKwh NEM spot price (c/kWh). This is the price generators get paid to generate electricity, and what drives the variable component of your perKwh price - includes GST
	SpotPerKwh float32 `json:"spotPerKwh"`

	// StartTime Start time of the interval in UTC. Formatted as a ISO 8601 time
	StartTime         time.Time            `json:"startTime"`
	TariffInformation *TariffInformation   `json:"tariffInformation"`
	Type              ForecastIntervalType `json:"type"`
}

// ForecastIntervalDuration Length of the interval in minutes.
type ForecastIntervalDuration int

// ForecastIntervalType defines model for ForecastInterval.Type.
type ForecastIntervalType string

// ForecastRenewable defines model for ForecastRenewable.
type ForecastRenewable struct {
	// Date Date the interval belongs to (in NEM time). This may be different to the date component of nemTime, as the last interval of the day ends at 12:00 the following day. Formatted as a ISO 8601 date
	Date openapi_types.Date `json:"date"`

	// Descriptor Describes the state of renewables. Gives you an indication of how green power is right now
	Descriptor RenewableDescriptor `json:"descriptor"`

	// Duration Length of the interval in minutes.
	Duration ForecastRenewableDuration `json:"duration"`

	// EndTime End time of the interval in UTC. Formatted as a ISO 8601 time
	EndTime time.Time `json:"endTime"`

	// NemTime The interval's NEM time. This represents the time at the end of the interval UTC+10. Formatted as a ISO 8601 time
	NemTime time.Time `json:"nemTime"`

	// Renewables Percentage of renewables in the grid
	Renewables float32 `json:"renewables"`

	// StartTime Start time of the interval in UTC. Formatted as a ISO 8601 time
	StartTime time.Time `json:"startTime"`
	Type      string    `json:"type"`
}

// ForecastRenewableDuration Length of the interval in minutes.
type ForecastRenewableDuration int

// Interval defines model for Interval.
type Interval struct {
	union json.RawMessage
}

// PriceDescriptor Describes the current price. Gives you an indication of how cheap the price is in relation to the average VMO and DMO. Note: Negative is no longer used. It has been replaced with extremelyLow.
type PriceDescriptor string

// Range When prices are particularly volatile, the API may return a range of NEM spot prices (c/kWh) that are possible.
type Range struct {
	// Max Estimated maximum price (c/kWh)
	Max float32 `json:"max"`

	// Min Estimated minimum price (c/kWh)
	Min float32 `json:"min"`
}

// Renewable defines model for Renewable.
type Renewable struct {
	union json.RawMessage
}

// RenewableDescriptor Describes the state of renewables. Gives you an indication of how green power is right now
type RenewableDescriptor string

// Site defines model for Site.
type Site struct {
	// ActiveFrom Date the site became active. This date will be in the future for pending sites. It may also be undefined, though if it is, contact [info@amber.com.au](mailto:info@amber.com.au) - there may be an issue with your address. Formatted as a ISO 8601 date when present.
	ActiveFrom *openapi_types.Date `json:"activeFrom,omitempty"`

	// Channels List of channels that are readable from your meter
	Channels []Channel `json:"channels"`

	// ClosedOn Date the site closed. Undefined if the site is pending or active. Formatted as a ISO 8601 date when present.
	ClosedOn *openapi_types.Date `json:"closedOn,omitempty"`

	// Id Unique Site Identifier
	Id string `json:"id"`

	// IntervalLength Length of interval that you will be billed on. 5 or 30 minutes.
	IntervalLength SiteIntervalLength `json:"intervalLength"`

	// Network The name of the site's network
	Network string `json:"network"`

	// Nmi National Metering Identifier (NMI) for the site
	Nmi string `json:"nmi"`

	// Status Site status.
	//
	// Pending sites are still in the process of being transferred. Note: We only include sites that have correct address details. If you expect to see a site, but don't, you may need to contact [info@amber.com.au](mailto:info@amber.com.au) to check that the address is correct.
	//
	// Active sites are ones that we actively supply electricity to.
	//
	// Closed sites are old sites that we no longer supply.
	Status SiteStatus `json:"status"`
}

// SiteIntervalLength Length of interval that you will be billed on. 5 or 30 minutes.
type SiteIntervalLength float32

// SiteStatus Site status.
//
// Pending sites are still in the process of being transferred. Note: We only include sites that have correct address details. If you expect to see a site, but don't, you may need to contact [info@amber.com.au](mailto:info@amber.com.au) to check that the address is correct.
//
// Active sites are ones that we actively supply electricity to.
//
// Closed sites are old sites that we no longer supply.
type SiteStatus string

// SpikeStatus Indicates whether this interval will potentially spike, or is currently in a spike state
type SpikeStatus string

// TariffInformation Information about how your tariff affects an interval
type TariffInformation struct {
	// Block The block that is currently active. Only available in the site in on a block tariff
	Block *float32 `json:"block,omitempty"`

	// DemandWindow Is this interval currently in the demand window? Only available if the site in on a demand tariff
	DemandWindow *bool `json:"demandWindow,omitempty"`

	// Period The Time of Use period that is currently active. Only available if the site in on a time of use tariff
	Period *TariffInformationPeriod `json:"period,omitempty"`

	// Season The Time of Use season that is currently active. Only available if the site in on a time of use tariff
	Season *TariffInformationSeason `json:"season,omitempty"`
}

// TariffInformationPeriod The Time of Use period that is currently active. Only available if the site in on a time of use tariff
type TariffInformationPeriod string

// TariffInformationSeason The Time of Use season that is currently active. Only available if the site in on a time of use tariff
type TariffInformationSeason string

// Usage defines model for Usage.
type Usage struct {
	// ChannelIdentifier Meter channel identifier
	ChannelIdentifier string `json:"channelIdentifier"`

	// ChannelType Meter channel type
	ChannelType ChannelType `json:"channelType"`

	// Cost The total cost of your consumption or generation for this period - includes GST
	Cost float32 `json:"cost"`

	// Date Date the interval belongs to (in NEM time). This may be different to the date component of nemTime, as the last interval of the day ends at 12:00 the following day. Formatted as a ISO 8601 date
	Date openapi_types.Date `json:"date"`

	// Descriptor Describes the current price. Gives you an indication of how cheap the price is in relation to the average VMO and DMO. Note: Negative is no longer used. It has been replaced with extremelyLow.
	Descriptor PriceDescriptor `json:"descriptor"`

	// Duration Length of the interval in minutes.
	Duration UsageDuration `json:"duration"`

	// EndTime End time of the interval in UTC. Formatted as a ISO 8601 time
	EndTime time.Time `json:"endTime"`

	// Kwh Number of kWh you consumed or generated. Generated numbers will be negative
	Kwh float32 `json:"kwh"`

	// NemTime The interval's NEM time. This represents the time at the end of the interval UTC+10. Formatted as a ISO 8601 time
	NemTime time.Time `json:"nemTime"`

	// PerKwh Number of cents you will pay per kilowatt-hour (c/kWh) - includes GST
	PerKwh float32 `json:"perKwh"`

	// Quality If the metering company has had trouble contacting your meter, they may make an estimate of your usage for that period. Billable data is data that will appear on your bill.
	Quality UsageQuality `json:"quality"`

	// Renewables Percentage of renewables in the grid
	Renewables float32 `json:"renewables"`

	// SpikeStatus Indicates whether this interval will potentially spike, or is currently in a spike state
	SpikeStatus SpikeStatus `json:"spikeStatus"`

	// SpotPerKwh NEM spot price (c/kWh). This is the price generators get paid to generate electricity, and what drives the variable component of your perKwh price - includes GST
	SpotPerKwh float32 `json:"spotPerKwh"`

	// StartTime Start time of the interval in UTC. Formatted as a ISO 8601 time
	StartTime         time.Time          `json:"startTime"`
	TariffInformation *TariffInformation `json:"tariffInformation"`
	Type              UsageType          `json:"type"`
}

// UsageDuration Length of the interval in minutes.
type UsageDuration int

// UsageQuality If the metering company has had trouble contacting your meter, they may make an estimate of your usage for that period. Billable data is data that will appear on your bill.
type UsageQuality string

// UsageType defines model for Usage.Type.
type UsageType string

// GetPricesParams defines parameters for GetPrices.
type GetPricesParams struct {
	// StartDate Return all prices for each interval on and after this day. Defaults to today. The difference between `startDate` and `endDate` must not exceed 7 days.
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate Return all prices for each interval on and before this day. Defaults to today. The difference between `startDate` and `endDate` must not exceed 7 days.
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// Resolution Specify the required interval duration resolution. Valid options: 5, 30. Default: Your billing interval length.
	Resolution *GetPricesParamsResolution `form:"resolution,omitempty" json:"resolution,omitempty"`
}

// GetPricesParamsResolution defines parameters for GetPrices.
type GetPricesParamsResolution int

// GetCurrentPricesParams defines parameters for GetCurrentPrices.
type GetCurrentPricesParams struct {
	// Next Return the _next_ number of forecast intervals. The total number of intervals requested must not exceed 2048.
	Next *int `form:"next,omitempty" json:"next,omitempty"`

	// Previous Return the _previous_ number of actual intervals. The total number of intervals requested must not exceed 2048.
	Previous *int `form:"previous,omitempty" json:"previous,omitempty"`

	// Resolution Specify the required interval duration resolution. Valid options: 5, 30. Default: Your billing interval length.
	Resolution *GetCurrentPricesParamsResolution `form:"resolution,omitempty" json:"resolution,omitempty"`
}

// GetCurrentPricesParamsResolution defines parameters for GetCurrentPrices.
type GetCurrentPricesParamsResolution int

// GetUsageParams defines parameters for GetUsage.
type GetUsageParams struct {
	// StartDate Return all usage for each interval on and after this day. The difference between `startDate` and `endDate` must not exceed 7 days.
	StartDate openapi_types.Date `form:"startDate" json:"startDate"`

	// EndDate Return all usage for each interval on and before this day. The difference between `startDate` and `endDate` must not exceed 7 days.
	EndDate openapi_types.Date `form:"endDate" json:"endDate"`

	// Resolution Deprecated. Usage will always be returned in your billing interval length. If you supply this parameter, it will be ignored.
	Resolution *GetUsageParamsResolution `form:"resolution,omitempty" json:"resolution,omitempty"`
}

// GetUsageParamsResolution defines parameters for GetUsage.
type GetUsageParamsResolution int

// GetCurrentRenewablesParams defines parameters for GetCurrentRenewables.
type GetCurrentRenewablesParams struct {
	// Next Return the _next_ number of forecast intervals
	Next *int `form:"next,omitempty" json:"next,omitempty"`

	// Previous Return the _previous_ number of actual intervals.
	Previous *int `form:"previous,omitempty" json:"previous,omitempty"`

	// Resolution Specify the required interval duration resolution. Valid options: 5, 30. Default: 30
	Resolution *GetCurrentRenewablesParamsResolution `form:"resolution,omitempty" json:"resolution,omitempty"`
}

// GetCurrentRenewablesParamsResolution defines parameters for GetCurrentRenewables.
type GetCurrentRenewablesParamsResolution int

// AsActualInterval returns the union data inside the Interval as a ActualInterval
func (t Interval) AsActualInterval() (ActualInterval, error) {
	var body ActualInterval
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActualInterval overwrites any union data inside the Interval as the provided ActualInterval
func (t *Interval) FromActualInterval(v ActualInterval) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActualInterval performs a merge with any union data inside the Interval, using the provided ActualInterval
func (t *Interval) MergeActualInterval(v ActualInterval) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCurrentInterval returns the union data inside the Interval as a CurrentInterval
func (t Interval) AsCurrentInterval() (CurrentInterval, error) {
	var body CurrentInterval
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCurrentInterval overwrites any union data inside the Interval as the provided CurrentInterval
func (t *Interval) FromCurrentInterval(v CurrentInterval) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCurrentInterval performs a merge with any union data inside the Interval, using the provided CurrentInterval
func (t *Interval) MergeCurrentInterval(v CurrentInterval) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForecastInterval returns the union data inside the Interval as a ForecastInterval
func (t Interval) AsForecastInterval() (ForecastInterval, error) {
	var body ForecastInterval
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForecastInterval overwrites any union data inside the Interval as the provided ForecastInterval
func (t *Interval) FromForecastInterval(v ForecastInterval) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForecastInterval performs a merge with any union data inside the Interval, using the provided ForecastInterval
func (t *Interval) MergeForecastInterval(v ForecastInterval) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Interval) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Interval) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsActualRenewable returns the union data inside the Renewable as a ActualRenewable
func (t Renewable) AsActualRenewable() (ActualRenewable, error) {
	var body ActualRenewable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActualRenewable overwrites any union data inside the Renewable as the provided ActualRenewable
func (t *Renewable) FromActualRenewable(v ActualRenewable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActualRenewable performs a merge with any union data inside the Renewable, using the provided ActualRenewable
func (t *Renewable) MergeActualRenewable(v ActualRenewable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCurrentRenewable returns the union data inside the Renewable as a CurrentRenewable
func (t Renewable) AsCurrentRenewable() (CurrentRenewable, error) {
	var body CurrentRenewable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCurrentRenewable overwrites any union data inside the Renewable as the provided CurrentRenewable
func (t *Renewable) FromCurrentRenewable(v CurrentRenewable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCurrentRenewable performs a merge with any union data inside the Renewable, using the provided CurrentRenewable
func (t *Renewable) MergeCurrentRenewable(v CurrentRenewable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForecastRenewable returns the union data inside the Renewable as a ForecastRenewable
func (t Renewable) AsForecastRenewable() (ForecastRenewable, error) {
	var body ForecastRenewable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForecastRenewable overwrites any union data inside the Renewable as the provided ForecastRenewable
func (t *Renewable) FromForecastRenewable(v ForecastRenewable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForecastRenewable performs a merge with any union data inside the Renewable, using the provided ForecastRenewable
func (t *Renewable) MergeForecastRenewable(v ForecastRenewable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Renewable) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Renewable) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetSites request
	GetSites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrices request
	GetPrices(ctx context.Context, siteId string, params *GetPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentPrices request
	GetCurrentPrices(ctx context.Context, siteId string, params *GetCurrentPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsage request
	GetUsage(ctx context.Context, siteId string, params *GetUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentRenewables request
	GetCurrentRenewables(ctx context.Context, state string, params *GetCurrentRenewablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetSites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrices(ctx context.Context, siteId string, params *GetPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPricesRequest(c.Server, siteId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentPrices(ctx context.Context, siteId string, params *GetCurrentPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentPricesRequest(c.Server, siteId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsage(ctx context.Context, siteId string, params *GetUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageRequest(c.Server, siteId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentRenewables(ctx context.Context, state string, params *GetCurrentRenewablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentRenewablesRequest(c.Server, state, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetSitesRequest generates requests for GetSites
func NewGetSitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPricesRequest generates requests for GetPrices
func NewGetPricesRequest(server string, siteId string, params *GetPricesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "siteId", runtime.ParamLocationPath, siteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sites/%s/prices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentPricesRequest generates requests for GetCurrentPrices
func NewGetCurrentPricesRequest(server string, siteId string, params *GetCurrentPricesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "siteId", runtime.ParamLocationPath, siteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sites/%s/prices/current", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Previous != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "previous", runtime.ParamLocationQuery, *params.Previous); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsageRequest generates requests for GetUsage
func NewGetUsageRequest(server string, siteId string, params *GetUsageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "siteId", runtime.ParamLocationPath, siteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sites/%s/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentRenewablesRequest generates requests for GetCurrentRenewables
func NewGetCurrentRenewablesRequest(server string, state string, params *GetCurrentRenewablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "state", runtime.ParamLocationPath, state)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/state/%s/renewables/current", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Previous != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "previous", runtime.ParamLocationQuery, *params.Previous); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetSitesWithResponse request
	GetSitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSitesResponse, error)

	// GetPricesWithResponse request
	GetPricesWithResponse(ctx context.Context, siteId string, params *GetPricesParams, reqEditors ...RequestEditorFn) (*GetPricesResponse, error)

	// GetCurrentPricesWithResponse request
	GetCurrentPricesWithResponse(ctx context.Context, siteId string, params *GetCurrentPricesParams, reqEditors ...RequestEditorFn) (*GetCurrentPricesResponse, error)

	// GetUsageWithResponse request
	GetUsageWithResponse(ctx context.Context, siteId string, params *GetUsageParams, reqEditors ...RequestEditorFn) (*GetUsageResponse, error)

	// GetCurrentRenewablesWithResponse request
	GetCurrentRenewablesWithResponse(ctx context.Context, state string, params *GetCurrentRenewablesParams, reqEditors ...RequestEditorFn) (*GetCurrentRenewablesResponse, error)
}

type GetSitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Site
}

// Status returns HTTPResponse.Status
func (r GetSitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Interval
}

// Status returns HTTPResponse.Status
func (r GetPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Interval
}

// Status returns HTTPResponse.Status
func (r GetCurrentPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Usage
}

// Status returns HTTPResponse.Status
func (r GetUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentRenewablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Renewable
}

// Status returns HTTPResponse.Status
func (r GetCurrentRenewablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentRenewablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetSitesWithResponse request returning *GetSitesResponse
func (c *ClientWithResponses) GetSitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSitesResponse, error) {
	rsp, err := c.GetSites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitesResponse(rsp)
}

// GetPricesWithResponse request returning *GetPricesResponse
func (c *ClientWithResponses) GetPricesWithResponse(ctx context.Context, siteId string, params *GetPricesParams, reqEditors ...RequestEditorFn) (*GetPricesResponse, error) {
	rsp, err := c.GetPrices(ctx, siteId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPricesResponse(rsp)
}

// GetCurrentPricesWithResponse request returning *GetCurrentPricesResponse
func (c *ClientWithResponses) GetCurrentPricesWithResponse(ctx context.Context, siteId string, params *GetCurrentPricesParams, reqEditors ...RequestEditorFn) (*GetCurrentPricesResponse, error) {
	rsp, err := c.GetCurrentPrices(ctx, siteId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentPricesResponse(rsp)
}

// GetUsageWithResponse request returning *GetUsageResponse
func (c *ClientWithResponses) GetUsageWithResponse(ctx context.Context, siteId string, params *GetUsageParams, reqEditors ...RequestEditorFn) (*GetUsageResponse, error) {
	rsp, err := c.GetUsage(ctx, siteId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageResponse(rsp)
}

// GetCurrentRenewablesWithResponse request returning *GetCurrentRenewablesResponse
func (c *ClientWithResponses) GetCurrentRenewablesWithResponse(ctx context.Context, state string, params *GetCurrentRenewablesParams, reqEditors ...RequestEditorFn) (*GetCurrentRenewablesResponse, error) {
	rsp, err := c.GetCurrentRenewables(ctx, state, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentRenewablesResponse(rsp)
}

// ParseGetSitesResponse parses an HTTP response from a GetSitesWithResponse call
func ParseGetSitesResponse(rsp *http.Response) (*GetSitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPricesResponse parses an HTTP response from a GetPricesWithResponse call
func ParseGetPricesResponse(rsp *http.Response) (*GetPricesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Interval
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCurrentPricesResponse parses an HTTP response from a GetCurrentPricesWithResponse call
func ParseGetCurrentPricesResponse(rsp *http.Response) (*GetCurrentPricesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Interval
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsageResponse parses an HTTP response from a GetUsageWithResponse call
func ParseGetUsageResponse(rsp *http.Response) (*GetUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Usage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCurrentRenewablesResponse parses an HTTP response from a GetCurrentRenewablesWithResponse call
func ParseGetCurrentRenewablesResponse(rsp *http.Response) (*GetCurrentRenewablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentRenewablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Renewable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"dRK8EJ0CmsPlUXT96vr/AgAA//9ohWsmOVQAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
